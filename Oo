在SceneKit中，您可以使用`SCNGeometry`来根据一组离散的点绘制一条连续的实线。具体来说，您可以使用`SCNGeometrySource`和`SCNGeometryElement`来创建自定义的几何形状。

以下是一个简单的Objective-C代码示例，演示如何根据一组离散的点（存储在`NSArray`中）绘制一条连续的实线：

```objc
#import <SceneKit/SceneKit.h>

// 假设您已经有了一个表示空间中一条曲线的离散点集合
NSArray<NSValue *> *points = @[
    [NSValue valueWithSCNVector3:SCNVector3Make(0, 0, 0)],
    [NSValue valueWithSCNVector3:SCNVector3Make(1, 1, 0)],
    [NSValue valueWithSCNVector3:SCNVector3Make(2, 0, 0)],
    // ... 更多点
];

// 创建一个用于存储点坐标的数组
NSInteger vertexCount = points.count;
float *vertices = malloc(sizeof(float) * 3 * vertexCount);

// 填充点坐标数组
for (NSInteger i = 0; i < vertexCount; ++i) {
    SCNVector3 point = [points[i] SCNVector3Value];
    vertices[i * 3] = point.x;
    vertices[i * 3 + 1] = point.y;
    vertices[i * 3 + 2] = point.z;
}

// 创建SCNGeometrySource
SCNGeometrySource *vertexSource = [SCNGeometrySource geometrySourceWithData:[NSData dataWithBytes:vertices length:sizeof(float) * 3 * vertexCount]
                                                                     semantic:SCNGeometrySourceSemanticVertex
                                                                  vectorCount:vertexCount
                                                              floatComponents:YES
                                                          componentsPerVector:3
                                                            bytesPerComponent:sizeof(float)
                                                                   dataOffset:0
                                                                   dataStride:sizeof(float) * 3];

// 创建SCNGeometryElement
NSInteger *indices = malloc(sizeof(NSInteger) * (vertexCount - 1) * 2);
for (NSInteger i = 0; i < vertexCount - 1; ++i) {
    indices[i * 2] = i;
    indices[i * 2 + 1] = i + 1;
}
SCNGeometryElement *element = [SCNGeometryElement geometryElementWithData:[NSData dataWithBytes:indices length:sizeof(NSInteger) * (vertexCount - 1) * 2]
                                                           primitiveType:SCNGeometryPrimitiveTypeLine
                                                          primitiveCount:vertexCount - 1
                                                           bytesPerIndex:sizeof(NSInteger)];

// 创建SCNGeometry
SCNGeometry *line = [SCNGeometry geometryWithSources:@[vertexSource] elements:@[element]];

// 添加到场景中
SCNNode *lineNode = [SCNNode nodeWithGeometry:line];
[self.sceneView.scene.rootNode addChildNode:lineNode];

// 释放内存
free(vertices);
free(indices);
```

这里，我们首先创建一个`SCNGeometrySource`来表示点的坐标，然后创建一个`SCNGeometryElement`来表示如何将这些点连接起来。最后，我们使用这两者来创建一个`SCNGeometry`对象，该对象可以添加到场景中。

注意：这个示例假设您已经有了一个`SCNView`对象（`self.sceneView`）和一个场景（`self.sceneView.scene`）。请根据您的实际需求进行相应的调整。希望这能帮助您实现所需的效果！

---
连接短圆柱
for (NSInteger i = 0; i < vertexCount - 1; ++i) {
    SCNVector3 start = [points[i] SCNVector3Value];
    SCNVector3 end = [points[i + 1] SCNVector3Value];
    SCNVector3 midPoint = SCNVector3Make((start.x + end.x) / 2, (start.y + end.y) / 2, (start.z + end.z) / 2);

    float length = sqrtf(powf(end.x - start.x, 2) + powf(end.y - start.y, 2) + powf(end.z - start.z, 2));

    SCNCylinder *cylinder = [SCNCylinder cylinderWithRadius:0.1 height:length]; // 设置半径来控制粗细
    SCNNode *cylinderNode = [SCNNode nodeWithGeometry:cylinder];
    cylinderNode.position = midPoint;
    cylinderNode.eulerAngles = // 设置以使其与两点之间的线段对齐

    [self.sceneView.scene.rootNode addChildNode:cylinderNode];
}


---
烟雾粒子
// 创建和配置粒子系统
SCNParticleSystem *particleSystem = [SCNParticleSystem particleSystemNamed:@"smoke" inDirectory:nil];
particleSystem.particleImage = [UIImage imageNamed:@"smokeImage.png"];
particleSystem.birthRate = 500;
particleSystem.particleLifeSpan = 5.0;
particleSystem.particleVelocity = 0;
particleSystem.emissionDuration = 1.0;

// 创建一个节点并将粒子系统附加到该节点
SCNNode *particleNode = [SCNNode node];
[particleNode addParticleSystem:particleSystem];

// 将particleNode添加到场景或其它适当的父节点
[scene.rootNode addChildNode:particleNode];

// 在更新块中设置particleNode的位置
void (^updateBlock)(void) = ^{
    if (currentIndex < [pathPoints count]) {
        SCNVector3 point = [pathPoints[currentIndex] SCNVector3Value];
        planeNode.position = point;
        particleNode.position = point;  // 将烟雾的位置设置为飞机当前位置
        currentIndex++;
    }
};

